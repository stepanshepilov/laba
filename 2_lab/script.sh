#!/bin/bash

# $(hostname) в Docker возвращает уникальный ID контейнера (короткий хэш).
CONTAINER_ID=$(hostname) 
SEQ=1 # Счётчик файлов для конкретно ЭТОГО контейнера

# Создаем пустой файл-замок. Если он уже есть, touch просто обновит время (не страшно).
# Он нужен, чтобы вешать на него блокировку.
touch /shared_volume/lockfile 

while true; do
    # НАЧАЛО КРИТИЧЕСКОЙ СЕКЦИИ
    {
        # flock -x 200: Попытаться получить ЭКСКЛЮЗИВНУЮ (-x) блокировку на дескриптор файла 200.
        # Если другой контейнер уже держит блокировку, этот процесс ЗАВИСНЕТ здесь и будет ждать.
        flock -x 200
        
        # --- Поиск свободного имени ---
        N=1
        # Цикл проверяет существование файлов: 001, 002...
        # printf '%03d' делает формат 001 вместо 1.
        while [ -e "/shared_volume/$(printf '%03d' $N)" ]; do
            N=$((N + 1))
        done
        
        # Мы нашли N, которого нет. Формируем имя.
        filename=$(printf '%03d' $N)
        
        # Записываем данные: ID контейнера и его личный счетчик.
        # Это и есть "создание файла".
        echo "$CONTAINER_ID $SEQ" > "/shared_volume/$filename"
        
        # Увеличиваем личный счетчик
        SEQ=$((SEQ + 1))
        
    } 200> /shared_volume/lockfile 
    # ^ Вся фигурная скобка { ... } связана с дескриптором 200, 
    # который направлен на файл lockfile.
    # Как только выполнение выходит из блока { }, дескриптор закрывается, 
    # и блокировка (flock) снимается АВТОМАТИЧЕСКИ.
    # КОНЕЦ КРИТИЧЕСКОЙ СЕКЦИИ

    # Задержка по заданию. Она ВНЕ блокировки, чтобы другие контейнеры могли работать, пока этот спит.
    sleep 1
    
    # Удаление файла.
    # В задании сказано: "Определение имени и создание... атомарная операция".
    # Удаление не обязательно должно быть под блокировкой, так как мы удаляем 
    # только свой файл (другие контейнеры не трогают чужие файлы).
    rm "/shared_volume/$filename"
done